{% extends "base.html" %}
{% load staticfiles %}
{% block content %}

<div class="container-fluid">
	<div class="row">
		<div class="col-md-12">
            <div id="map" style="height: 400px; width:100%"> </div>
            <script src="{% static 'bootstrap/js/bootstrap.min.js' %}"></script>
            <!-- JQUERY is not needed but lets just be nice to ourselves... -->
            <script src="{% static 'bootstrap/js/jquery-1.11.0.js' %}"></script>
            <!-- sock.js is very highly recomended (required even!) for implementing websockets. -->
            <script src="http://cdn.sockjs.org/sockjs-0.3.min.js"></script>
            <script type="text/javascript">

                {% if address %}
                    SOCKET_ADDRESS='{{address}}';
                {% else %}
                    SOCKET_ADDRESS=null;
                {% endif %}

                var map = L.map('map');

                L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors',
                maxZoom: 18
                }).addTo(map);

                //

                {% if history %}
                    var markerArray = [];
                    {% for message in history %}
                        markerArray.push(L.marker([{{ message.lat }}, {{ message.lon }}]));
                    {% endfor %}
                    var group = L.featureGroup(markerArray).addTo(map);
                    map.fitBounds(group.getBounds());
                {% else %}
                    map.locate({setView: true, maxZoom: 8});
                    var markerArray = [];
                    //see: http://ipasic.com/article/create-real-time-web-gis-applications-html5-websockets-and-tornado/
                    function DisplayNewPosition(lat,lon) {
                        //marker = L.marker([lat,lon]).addTo(map);
                        //map.setView([lat,lon], 12);
                        markerArray.push(L.marker([lat,lon]));
                        var group = L.featureGroup(markerArray).addTo(map);
                        map.fitBounds(group.getBounds());
                    }
                {% endif %}


                var setup_chat = function(sock){

                    //this is
                    $('#chat_entry').on('keypress',function(e){
                        //send on enter key pressed...
                        if (e.keyCode === 13){
                            $el = $(this);

                            sock.send(
                                JSON.stringify({

                                    // make sure what you put in the socket is what your
                                    // backend code is expecting

                                    message:$el.val(),
                                    sender :$('#nickname').val() || 'anonymous',
                                    channel:SOCKET_ADDRESS
                                }))

                            $(this).val('');
                        }
                    })

                    sock.onmessage = function(e) {
                        //

                        var data = JSON.parse(e.data);


                        if(data.html){
                            $('#empty').remove();
                            $('#history').append($(data.html));
                            $("#history").animate({ scrollTop: $('#history')[0].scrollHeight}, 1000);

                        }
                        if(data.lat){
                            console.log(data.lat);
                            var object = JSON.parse(e.data);
                            lat=object.lat
                            lon=object.lon
                            console.log("Lat: " + lat +", Lon: "+lon);
                            DisplayNewPosition(lat,lon);
                        }
                    }
                }

                $(function(){

                    var sock = new SockJS('/messages/main/');

                    sock.onopen = function() {

                        // "hx_subscribe" is a keyword that tells hendrix to subscribe the
                        // socket transport associated with this web browser session
                        // with a given channel

                        this.send(JSON.stringify({'hx_subscribe':SOCKET_ADDRESS}));

                        // we need to wait until we have a socket connection established before
                        // hooking up the events.

                        setup_chat(this);

                        $("#history").animate({ scrollTop: $('#history')[0].scrollHeight}, 1000);
                    };
                })
            </script>
		</div>
    </div>
    <div><p></p></div>
	<div class="row">
		<div class="col-md-12">
            <div id="history">
            {% for message in history %}
                {% include 'message.html' %}
            {% empty %}
                <li id="empty">no history</li>
            {% endfor %}
            </div>
        </div>
	</div>
</div>

{% endblock %}
